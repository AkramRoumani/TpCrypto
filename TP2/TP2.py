import numpy as np
import binascii

# Partie 1 :

Sbox = (
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,  # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,  # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,  # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,  # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,  # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,  # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,  # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,  # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,  # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,  # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,  # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,  # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,  # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,  # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,  # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16   # f
)

# Effectue l'opération subbyte
def subbyte (a) :
    return [[Sbox[byte] for byte in row] for row in a]

# Effectue l'opération shiftRows
def shiftrows(a) :
    return [a[0], 
            a[1][1:] + a[1][:1], 
            a[2][2:] + a[2][:2], 
            a[3][3:] + a[3][:3]]

# Effectue l'opération mixColumns
def mixColumns(a) :
        
    X = np.array([
        [0x02, 0x03, 0x01, 0x01],
        [0x01, 0x02, 0x03, 0x01],
        [0x01, 0x01, 0x02, 0x03],
        [0x03, 0x01, 0x01, 0x02]
    ], dtype=np.uint8)
    a_transpose = np.array(a, dtype=np.uint8).T
    result = np.zeros_like(a_transpose)
    for i in range(4):
        for j in range(4):
            s = 0
            for k in range(4):
                x = X[j][k]
                v = a_transpose[i][k]
                for bit in range(8):
                    if x & (1 << bit):
                        s ^= v << bit
                        s ^= (0x11b if (s & 0x100) else 0x00)
            # Only the lower 8 bits are of interest after the modulo operation
            result[i][j] = s & 0xff
    result_transposed = result.T
    return result_transposed

# Création des clés pour les ajouter par la suite durant les étapes du cryptage
def key_expansion(key, Sbox, rc):
    
    Nk = 4
    Nr = 10
    Nb = 4

    def sub_word(word):
        return [Sbox[byte] for byte in word]

    def rot_word(word):
        return word[1:] + word[:1]

    key_schedule = list(key)

    for i in range(Nk, Nb * (Nr + 1)):
        temp = key_schedule[-Nk:]
        if i % Nk == 0:
            temp = sub_word(rot_word(temp))
            temp[0] ^= rc[i // Nk - 1]
        new_word = [a ^ b for a, b in zip(key_schedule[-Nb * Nk:], temp)]
        key_schedule.extend(new_word)

    key_rounds = [key_schedule[i:i + Nb*4] for i in range(0, len(key_schedule), Nb*4)]

    # Convert to hexadecimal format but keep as integers
    key_rounds_hex = [[int(f'0x{x:02x}', 16) for x in round_key] for round_key in key_rounds]

    return key_rounds_hex

# Ajout de la clé
def add_round_key(state, round_key):
    """XOR the state matrix 'a' with the round key."""
    new_state = [[state[i][j] ^ round_key[i][j] for j in range(4)] for i in range(4)]
    hex_state = [[int(x) for x in row] for row in new_state]  # Convert back to integer format
    return hex_state

key_hex = ['2b', '7e', '15', '16', '28', 'ae', 'd2', 'a6', 'ab', 'f7', '15', '88', '09', 'cf', '4f', '3c']
key = [int(k, 16) for k in key_hex]

# Matrice prise comme exemple sur le document : FIPS 197, Advanced Encryption Standard (AES). Sur mootse.
state = [
    [0x32, 0x88, 0x31, 0xe0],
    [0x43, 0x5a, 0x31, 0x37],
    [0xf6, 0x30, 0x98, 0x07],
    [0xa8, 0x8d, 0xa2, 0x34]
]

rc = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]

key_expanded = key_expansion(key, Sbox, rc)

# Organisation des clés
use_key = []
for i in range (11) :
    use_key.append([
        [key_expanded[i][0],key_expanded[i][4],key_expanded[i][8],key_expanded[i][12]],
        [key_expanded[i][1],key_expanded[i][5],key_expanded[i][9],key_expanded[i][13]],
        [key_expanded[i][2],key_expanded[i][6],key_expanded[i][10],key_expanded[i][14]],
        [key_expanded[i][3],key_expanded[i][7],key_expanded[i][11],key_expanded[i][15]]
    ])


# Fonction qui effectue le cryptage complet
def complete_encryption(state) :
    state=add_round_key(state,use_key[0])
    for i in range(1,10) :
        state=subbyte(state)
        state=shiftrows(state)
        state=mixColumns(state)
        state=add_round_key(state,use_key[i])
    state=subbyte(state)
    state=shiftrows(state)
    state=add_round_key(state,use_key[10])
    return(state)


# Partie 2 :

# On définit l'inverse de la SBox
InvSbox = (
0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
)

# Fonction qui effectue l'inverse de subbyte
def inv_subbyte(a):
    return [[InvSbox[byte] for byte in row] for row in a]

# Fonction qui effectue l'inverse de shiftRows
def inv_shiftrows(state):
    # Assuming 'state' is a list of lists or a 2D numpy array
    new_state = [state[0],  # No shift for the first row
                 state[1][-1:] + state[1][:-1],  # Shift left by 1
                 state[2][-2:] + state[2][:-2],  # Shift left by 2
                 state[3][-3:] + state[3][:-3]]  # Shift left by 3
    return new_state

# Fonction qui effectue l'inverse de MixColumns
def invMixColumns(a):
    def gf_mul(x, y): # Multiplie deux nombres en GF(2^8)
        result = 0
        for i in range(8):
            if y & 1:
                result ^= x
            carry = x & 0x80
            x <<= 1
            if carry:
                x ^= 0x11b
            y >>= 1
        return result

# Inverse de la matrice de mixcolumns
    X_inv = np.array([
        [0x0e, 0x0b, 0x0d, 0x09],
        [0x09, 0x0e, 0x0b, 0x0d],
        [0x0d, 0x09, 0x0e, 0x0b],
        [0x0b, 0x0d, 0x09, 0x0e]
    ], dtype=np.uint8)

    a_transpose = np.array(a, dtype=np.uint8).T
    result = np.zeros_like(a_transpose)

    for i in range(4):
        for j in range(4):
            s = 0
            for k in range(4):
                x = X_inv[j][k]
                v = a_transpose[i][k]
                s ^= gf_mul(x, v)
            result[i][j] = s & 0xff

    result_transposed = result.T
    return result_transposed.tolist()


# Fonction qui effectue le decryptage complet
def complete_decryption(state):
    state = add_round_key(state, use_key[10])
    state = inv_shiftrows(state)
    state = inv_subbyte(state)
    
    for i in range(9, 0, -1):
        state = add_round_key(state, use_key[i])
        state = invMixColumns(state)
        state = inv_shiftrows(state)
        state = inv_subbyte(state)
    
    state = add_round_key(state, use_key[0])
    return state

encrypted_state_hex = [[hex(x) for x in row] for row in complete_encryption(state)]
encrypted_state_hexx = [[hex(x) for x in row] for row in complete_decryption(complete_encryption(state))]
print(encrypted_state_hexx)
print(encrypted_state_hex)


#Partie 3

# Polynôme irréductible pour GF(2^8)
irreducible_poly = 0b100011011

def multiply_poly(a, b):
    result = 0
    while b > 0:
        if b & 1:
            result ^= a
        a <<= 1
        if a & 0x100:
            a ^= irreducible_poly
        b >>= 1
    return result

def inverse_in_gf2_8(x):
    # Utilise l'exponentiation par le carré pour trouver l'inverse
    if x == 0:
        return 0
    result = x
    for _ in range(1, 254):  # 254 = 2^8 - 2
        result = multiply_poly(result, x)
    return result

def apply_affine_transformation(x):
    affine_matrix = np.array([
        [1, 0, 0, 0, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 1, 1, 1],
        [1, 1, 1, 0, 0, 0, 1, 1],
        [1, 1, 1, 1, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 1, 1]
    ])
    constant_vector = np.array([1, 1, 0, 0, 0, 1, 1, 0])
    x_bits = np.array([int(bit) for bit in f'{x:08b}'][::-1])
    transformed_bits = np.dot(affine_matrix, x_bits) % 2
    return int(''.join(str(int(bit)) for bit in (transformed_bits ^ constant_vector)[::-1]), 2)

def s_box(x):
    return apply_affine_transformation(inverse_in_gf2_8(x))

# Example of using S-box
print(f"S-box(0x98) = {s_box(0x98):02x}") 
